from UI_ELEMENTS.base_element import BaseElementUI
from UI_ELEMENTS.shapes import RectAle, SurfaceAle
from math import ceil

DO_NOT_EXECUTE = False
if not DO_NOT_EXECUTE:
    import pygame
    from pygame.event import Event
    from UI_ELEMENTS.event_tracker import EventTracker
    from UI_ELEMENTS.element_text_label import Label_text
    from UI_ELEMENTS.element_button_toggle import Button_toggle


class Scroll(BaseElementUI):
    def __init__(self, x, y, w, h, origin='left-up', values=[], values_state=[], title="click me"):
        super().__init__(x, y, w, h, origin)

        self.shape.add_shape("bg", RectAle("0cw", "0ch", "100cw", "100ch", [40, 40, 40], 0, 0))
        self.shape.add_shape("bg_selectable", RectAle("0cw", "7.5ch", "100cw", "100ch -7.5ch", [50, 50, 50], 0, 0))
        
        self.componenets: dict[str, Label_text] = {
            "_title" : Label_text("3px", "0px", "100cw", "7.5ch", "left-up", text=title, text_tag_support=False, render_bg=False, text_centered_x=False)
        }

        for key, value in self.componenets.items():
            value.parent_object = self
        
        self.values = values
        self.values_state = values_state
        self.values_options_height = 30  # unit in pixels
        self.values_options_number = 1   # avoid edge cases 
        self.values_first_index = -1
        self.scroll_speed = 5

        self.pixels_scrolled = 0       


    @property
    def need_to_scroll(self):
        return len(self.values) > self.shape.shapes["bg_selectable"].h.value // self.values_options_height


    def handle_events(self, events: list['Event']):
            
        if self.is_enabled:
            # handle self components events
            [element.handle_events(events) for index, element in self.componenets.items()]
            
            # handle values options events
            [element.handle_events(events) for element in self.values_options]
            
            # handle values representations events
            [element.handle_events(events) for element in self.values_representations]

            need_to_update = self.update_values_state()
            if need_to_update:
                self.map_elements_to_UI()

            # get the latest events and relative positions
            tracker = EventTracker()

            if tracker.scrolled != 0 and self.bounding_box.collidepoint(tracker.get_local_mouse_pos(self.get_parent_local_offset())) and self.need_to_scroll:
                
                if (tracker.scrolled > 0 and self.values_first_index > -1) or (tracker.scrolled < 0 and self.values_first_index < len(self.values) - self.values_options_number + 1):
                    self.move_UI_elements(self.convert_scrolled_amount_in_px(tracker.scrolled))
                
                if tracker.scrolled > 0 and self.values_first_index == -1:
                    old_y = self.values_options[0].y.lst_str_value[0]
                    self.move_UI_elements(- int(old_y[:-2]))
                
                if tracker.scrolled < 0 and self.values_first_index >= len(self.values) - self.values_options_number + 1:
                    delta_to_be_covered = abs(self.shape.shapes["bg_selectable"].h.value - self.values_options_height * (self.values_options_number - 1))
                    
                    old_y = self.values_options[-1].y.lst_str_value[0]
                    new_y = max(int(old_y[:-2]) + self.convert_scrolled_amount_in_px(tracker.scrolled), self.values_options_height - delta_to_be_covered)
                                        
                    self.move_UI_elements(new_y - int(old_y[:-2]))

                self.map_elements_to_UI()

            elif not self.need_to_scroll:
                self.move_UI_elements(- int(self.values_options[0].y.lst_str_value[0][:-2]))
                self.set_first_index(-1)    # overwrites the overflow generated by setting the starting position        
                self.map_elements_to_UI()


            # Hover block #
            if self.bounding_box.collidepoint(tracker.get_local_mouse_pos(self.get_parent_local_offset())):
                self.is_hover_old = self.is_hover
                self.is_hover = True
            else:
                self.is_hover_old = self.is_hover
                self.is_hover = False
            
            
            if self.is_hover and self.is_hover != self.is_hover_old:
                self.shape.shapes["bg"].color += 5
            elif not self.is_hover and self.is_hover != self.is_hover_old:
                self.shape.shapes["bg"].color -= 5
            # Hover block #


    def launch_tab_action(self):
        ...

    
    def analyze_coordinate(self, offset_x=0, offset_y=0):
        super().analyze_coordinate(offset_x, offset_y)
    
        for name, child in self.componenets.items():
            child.analyze_coordinate(self.x.value, self.y.value)
        
        number_changed = self.determine_number_of_visible_options()

        if number_changed:
            self.generate_values_options()
            self.map_elements_to_UI()
            self.hide_values_out_of_range()
            
        for child in self.values_options:
            child.analyze_coordinate(self.x.value, self.y.value)
        
        for child in self.values_representations:
            child.analyze_coordinate(self.x.value, self.y.value)


    def get_render_objects(self):
        if self.is_enabled:
            ris = []
            
            # adds himself
            ris.extend(super().get_render_objects())
            
            # adds its components
            for name, obj in self.componenets.items():            
                ris.extend(obj.get_render_objects())
            
            # adds the values options
            for obj in self.values_options:            
                ris.extend(obj.get_render_objects())
            
            # adds the values options
            for obj in self.values_representations:            
                ris.extend(obj.get_render_objects())
            
            return ris
        else:
            return []
        

    def __repr__(self):
        return f"Scroll element containing {len(self.values)} elements and showing {self.values_options_number} objects. Starting index is {0}"
    

    def determine_number_of_visible_options(self) -> bool:
        old_values = self.values_options_number
        self.values_options_number =  ceil(self.shape.shapes["bg_selectable"].h.value / self.values_options_height) + 1
        return old_values != self.values_options_number
    

    def generate_values_options(self):
        self.values_options = [Button_toggle("2px", f"0px {self.values_options_height * (i - 1)}px 2px 7.5ch", f"{self.values_options_height - 4}px", f"{self.values_options_height - 4}px", "left-up", initial_status=False) for i in range(self.values_options_number)]
        self.values_representations = [Label_text("40px", f"0px {self.values_options_height * (i - 1)}px 2px 7.5ch", "100cw -45px", f"{self.values_options_height - 4}px", "left-up", text="", render_bg=False, text_centered_x=False) for i in range(self.values_options_number)]

        for value in self.values_options + self.values_representations:
            value.parent_object = self
            value.shape.set_clip_rect_parent(self.shape.shapes["bg_selectable"])


    def set_first_index(self, value):
        self.values_first_index = value


    def get_batch_of_candidate_elements(self) -> tuple[int, int]:
        '''
        Returns the indices of the elements to be rendered.
        Start is inclusive.
        End is exclusive.
        Great to be used directly in a range() function.
        '''
        return self.values_first_index, self.values_first_index + self.values_options_number
    

    def map_elements_to_UI(self):
        start, end = self.get_batch_of_candidate_elements()

        start = max(0, start) # ensures positive values
        end = min(len(self.values), end) # ensures no out of range values

        for i in range(start, end):
            self.values_options[i - self.values_first_index].set_state(self.values_state[i])
            self.values_representations[i - self.values_first_index].change_text(self.values[i])
            self.update_representations_appearence(self.values_representations[i - self.values_first_index], self.values_state[i])


    def update_values_state(self) -> bool:
        '''Updates the values of the state of the toggles and return if a modification was made.'''

        if len(self.values_state) == 0:
            return False # nothing changed

        states = [button.get_state() for button in self.values_options]
        old_values_state = [i for i in self.values_state]

        if self.values_first_index < 0:
            states = states[- self.values_first_index :]
            self.values_state[: min(len(self.values_state), len(states))] = states[: min(len(self.values_state), len(states))]

        else:
            self.values_state[self.values_first_index : self.values_first_index + self.values_options_number] = states

        return old_values_state != self.values_state



    def move_UI_elements(self, delta_px):
        for index, option, representation in zip(range(len(self.values_options)), self.values_options, self.values_representations):
            
            old_y = option.y.lst_str_value[0] # Il primo valore Ã¨ sempre rappresentato in px
            new_y = int(old_y[:-2]) + delta_px 
            position_overflow = new_y // self.values_options_height
            
            new_y -= position_overflow * self.values_options_height

            option.y.lst_str_value[0] = f"{new_y}px"
            representation.y.lst_str_value[0] = f"{new_y}px"

        self.set_first_index(self.values_first_index - position_overflow)        
        
        for child in self.values_options:
            child.analyze_coordinate(self.x.value, self.y.value)
        
        for child in self.values_representations:
            child.analyze_coordinate(self.x.value, self.y.value)


    def convert_scrolled_amount_in_px(self, delta_scrolled) -> int:
        return round(self.scroll_speed * delta_scrolled)
    

    def hide_values_out_of_range(self):
        
        for button, label in zip(self.values_options, self.values_representations):
            button.ask_enable_disable_element(True, 2)
            label.ask_enable_disable_element(True, 2)
    
        if not self.need_to_scroll:

            for button, label in zip(self.values_options[len(self.values) + 1:], self.values_representations[len(self.values) + 1:]):
                button.ask_enable_disable_element(False, 2)
                label.ask_enable_disable_element(False, 2)


    def update_representations_appearence(self, label, state):
        
        color = "aaffaa" if state else "aaaaaa"
        string = label.text
        
        starting_index = string.find("\\#")

        if starting_index == -1:
            label.change_text(f"\\#{color}{{" + string + "}")
        else:
            old_state = None
            if string.find("aaaaaa") != -1:
                old_state = False
            if string.find("aaffaa") != -1:
                old_state = True

            if old_state != state:
                string = string[:starting_index] + f"\\#{color}" + string[starting_index + 8:]
                label.change_text(string)


    def add_element(self, value, state, index=None):
        
        if index is None:
            self.values.append(value)
            self.values_state.append(state)
        else:
            self.values.insert(index, value)
            self.values_state.insert(index, state)
        
        self.hide_values_out_of_range()
        self.map_elements_to_UI()


    def remove_element(self, index=None):

        if len(self.values) == 0:
            return

        if index is None:
            self.values.pop()
            self.values_state.pop()
        else:
            self.values.pop(index)
            self.values_state.pop(index)
        
        if self.values_first_index > -1:
            self.values_first_index -= 1

        self.hide_values_out_of_range()
        self.map_elements_to_UI()